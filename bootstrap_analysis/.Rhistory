#
#this does not seem completely faithful to the way the simulation is done
#above how would you do it?
data = list('p0':observed_initial_pfus, 'p1':observed_final_pfus)
View(observed_initial_pfus)
set.seed(1)
nseqs = 500000
nstrains = 140
npfus = 10000
#experiment:
# npfus distributed amoung nstrains viruses (input), grown by a factor of rf (final)
# proportions of viruses in input and final are determined via sequencing
# total number of PFUs in final sample is determined via taqman ct
# initial number of PFUs is assumed to be 10000
# task: find rf
#generating simulated data which holds the place of the unobserved "real" data
simulated_input_proportions = runif(nstrains)
simulated_input_proportions = simulated_input_proportions/sum(simulated_input_proportions)
simulated_rfs = 2**(runif(nstrains)*12)
simulated_initial_pfus = rmultinom(n=1, size=npfus, prob=simulated_input_proportions)
simulated_final_pfus = simulated_initial_pfus * simulated_rfs
simulated_initial_pfu_props = simulated_initial_pfus/sum(simulated_initial_pfus)
simulated_final_pfu_props = simulated_final_pfus/sum(simulated_final_pfus)
#observed data
observed_initial_seqs = rmultinom(n=1, size=nseqs, prob=simulated_initial_pfu_props)
observed_final_seqs = rmultinom(n=1, size=nseqs, prob=simulated_final_pfu_props)
observed_initial_total_pfus = 10000 #they dont measure this but tell me that they fix it to
#10000 so for now I assume this is fixed
observed_final_total_pfus = as.integer(sum(simulated_final_pfus)*(2**rnorm(1, 0, sd=0.6))) #normally this is measured via
#taqman ct but it amounts to
#sth similiar to this
#how I do it:
#from observed_final_seqs and observed_initial_seqs compute proportions
#multiply the first by observed_final_total_pfus, the former bu observed_initial_total_pfus
#so
observed_initial_pfus = observed_initial_total_pfus * observed_initial_seqs/sum(observed_initial_seqs)
observed_final_pfus = observed_final_total_pfus * observed_final_seqs/sum(observed_final_seqs)
#
#rf ~ some prior
#p_initial ~ some prior
#
#observed_initial_pfus ~ Multinomial(size=sum(observed_initial_pfus), prob=p_initial)
#p_final = rf*p_initial
#observed_final_pfus ~ Multinomial(size=sum(observed_final_pfus), prob=p_final)
#
#this does not seem completely faithful to the way the simulation is done
#above how would you do it?
data = list("p0"=observed_initial_pfus, "p1"=observed_final_pfus)
set.seed(1)
nseqs = 500000
nstrains = 140
npfus = 10000
#experiment:
# npfus distributed amoung nstrains viruses (input), grown by a factor of rf (final)
# proportions of viruses in input and final are determined via sequencing
# total number of PFUs in final sample is determined via taqman ct
# initial number of PFUs is assumed to be 10000
# task: find rf
#generating simulated data which holds the place of the unobserved "real" data
simulated_input_proportions = runif(nstrains)
simulated_input_proportions = simulated_input_proportions/sum(simulated_input_proportions)
simulated_rfs = 2**(runif(nstrains)*12)
simulated_initial_pfus = rmultinom(n=1, size=npfus, prob=simulated_input_proportions)
simulated_final_pfus = simulated_initial_pfus * simulated_rfs
simulated_initial_pfu_props = simulated_initial_pfus/sum(simulated_initial_pfus)
simulated_final_pfu_props = simulated_final_pfus/sum(simulated_final_pfus)
#observed data
observed_initial_seqs = rmultinom(n=1, size=nseqs, prob=simulated_initial_pfu_props)
observed_final_seqs = rmultinom(n=1, size=nseqs, prob=simulated_final_pfu_props)
observed_initial_total_pfus = 10000 #they dont measure this but tell me that they fix it to
#10000 so for now I assume this is fixed
observed_final_total_pfus = as.integer(sum(simulated_final_pfus)*(2**rnorm(1, 0, sd=0.6))) #normally this is measured via
#taqman ct but it amounts to
#sth similiar to this
#how I do it:
#from observed_final_seqs and observed_initial_seqs compute proportions
#multiply the first by observed_final_total_pfus, the former bu observed_initial_total_pfus
#so
observed_initial_pfus = as.integer(observed_initial_total_pfus * observed_initial_seqs/sum(observed_initial_seqs))
observed_final_pfus = as.integer(observed_final_total_pfus * observed_final_seqs/sum(observed_final_seqs))
#
#rf ~ some prior
#p_initial ~ some prior
#
#observed_initial_pfus ~ Multinomial(size=sum(observed_initial_pfus), prob=p_initial)
#p_final = rf*p_initial
#observed_final_pfus ~ Multinomial(size=sum(observed_final_pfus), prob=p_final)
#
#this does not seem completely faithful to the way the simulation is done
#above how would you do it?
data = list("p0"=observed_initial_pfus, "p1"=observed_final_pfus)
View(data)
observed_final_total_pfus * observed_final_seqs/sum(observed_final_seqs)
rfs
set.seed(1)
nseqs = 500000
nstrains = 140
npfus = 10000
#experiment:
# npfus distributed amoung nstrains viruses (input), grown by a factor of rf (final)
# proportions of viruses in input and final are determined via sequencing
# total number of PFUs in final sample is determined via taqman ct
# initial number of PFUs is assumed to be 10000
# task: find rf
#generating simulated data which holds the place of the unobserved "real" data
simulated_input_proportions = runif(nstrains)
simulated_input_proportions = simulated_input_proportions/sum(simulated_input_proportions)
simulated_rfs = 2**(runif(nstrains)*12)
simulated_initial_pfus = rmultinom(n=1, size=npfus, prob=simulated_input_proportions)
simulated_final_pfus = simulated_initial_pfus * simulated_rfs
simulated_initial_pfu_props = simulated_initial_pfus/sum(simulated_initial_pfus)
simulated_final_pfu_props = simulated_final_pfus/sum(simulated_final_pfus)
#observed data
observed_initial_seqs = rmultinom(n=1, size=nseqs, prob=simulated_initial_pfu_props)
observed_final_seqs = rmultinom(n=1, size=nseqs, prob=simulated_final_pfu_props)
observed_initial_total_pfus = 10000 #they dont measure this but tell me that they fix it to
#10000 so for now I assume this is fixed
observed_final_total_pfus = as.integer(sum(simulated_final_pfus)*(2**rnorm(1, 0, sd=0.6))) #normally this is measured via
#taqman ct but it amounts to
#sth similiar to this
#how I do it:
#from observed_final_seqs and observed_initial_seqs compute proportions
#multiply the first by observed_final_total_pfus, the former bu observed_initial_total_pfus
#so
observed_initial_pfus = as.integer(observed_initial_total_pfus * (observed_initial_seqs/sum(observed_initial_seqs)))
observed_final_pfus = observed_final_total_pfus * (observed_final_seqs/sum(observed_final_seqs))
#
#rf ~ some prior
#p_initial ~ some prior
#
#observed_initial_pfus ~ Multinomial(size=sum(observed_initial_pfus), prob=p_initial)
#p_final = rf*p_initial
#observed_final_pfus ~ Multinomial(size=sum(observed_final_pfus), prob=p_final)
#
#this does not seem completely faithful to the way the simulation is done
#above how would you do it?
data = list("p0"=observed_initial_pfus, "p1"=observed_final_pfus)
View(data)
set.seed(1)
nseqs = 500000
nstrains = 140
npfus = 10000
#experiment:
# npfus distributed amoung nstrains viruses (input), grown by a factor of rf (final)
# proportions of viruses in input and final are determined via sequencing
# total number of PFUs in final sample is determined via taqman ct
# initial number of PFUs is assumed to be 10000
# task: find rf
#generating simulated data which holds the place of the unobserved "real" data
initial_proportions = runif(nstrains)
initial_proportions = initial_proportions/sum(initial_proportions)
rfs = 2**(runif(nstrains)*12)
initial_pfus = rmultinom(n=1, size=npfus, prob=initial_proportions)
final_pfus = initial_pfus * rfs
initial_pfu_props = initial_pfus/sum(initial_pfus)
final_pfu_props = final_pfus/sum(final_pfus)
#observed data
observed_initial_seqs = rmultinom(n=1, size=nseqs, prob=initial_pfu_props)
observed_final_seqs = rmultinom(n=1, size=nseqs, prob=final_pfu_props)
observed_initial_total_pfus = 10000 #they dont measure this but tell me that they fix it to
#10000 so for now I assume this is fixed
observed_final_total_pfus = as.integer(sum(final_pfus)*(2**rnorm(1, 0, sd=0.6))) #normally this is measured via
#taqman ct but it amounts to
#sth similiar to this
#how I do it:
#from observed_final_seqs and observed_initial_seqs compute proportions
#multiply the first by observed_final_total_pfus, the former bu observed_initial_total_pfus
#so
observed_initial_pfus = as.integer(observed_initial_total_pfus * (observed_initial_seqs/sum(observed_initial_seqs)))
observed_final_pfus = observed_final_total_pfus * (observed_final_seqs/sum(observed_final_seqs))
#
#log_rf ~ Uniform(0, 12)
#p_initial ~ Dirichlet
#rf = 2**log_rf
#
#observed_initial_pfus ~ Multinomial(size=sum(observed_initial_pfus), prob=p_initial)
#p_final = rf*p_initial
#observed_final_pfus ~ Multinomial(size=sum(observed_final_pfus), prob=p_final)
#
#this does not seem completely faithful to the way the simulation is done
#above how would you do it?
data = list("p0"=observed_initial_pfus, "p1"=observed_final_pfus)
set.seed(1)
nseqs = 500000
nstrains = 140
npfus = 10000
#experiment:
# npfus distributed amoung nstrains viruses (input), grown by a factor of rf (final)
# proportions of viruses in input and final are determined via sequencing
# total number of PFUs in final sample is determined via taqman ct
# initial number of PFUs is assumed to be 10000
# task: find rf
#generating simulated data which holds the place of the unobserved "real" data
initial_proportions = runif(nstrains)
initial_proportions = initial_proportions/sum(initial_proportions)
rfs = 2**(runif(nstrains)*12)
initial_pfus = rmultinom(n=1, size=npfus, prob=initial_proportions)
final_pfus = initial_pfus * rfs
initial_pfu_props = initial_pfus/sum(initial_pfus)
final_pfu_props = final_pfus/sum(final_pfus)
#observed data
observed_initial_seqs = rmultinom(n=1, size=nseqs, prob=initial_pfu_props)
observed_final_seqs = rmultinom(n=1, size=nseqs, prob=final_pfu_props)
observed_initial_total_pfus = 10000 #they dont measure this but tell me that they fix it to
#10000 so for now I assume this is fixed
observed_final_total_pfus = as.integer(sum(final_pfus)*(2**rnorm(1, 0, sd=0.6))) #normally this is measured via
#taqman ct but it amounts to
#sth similiar to this
#how I do it:
#from observed_final_seqs and observed_initial_seqs compute proportions
#multiply the first by observed_final_total_pfus, the former bu observed_initial_total_pfus
#so
observed_initial_pfus = as.integer(observed_initial_total_pfus * (observed_initial_seqs/sum(observed_initial_seqs)))
observed_final_pfus = observed_final_total_pfus * (observed_final_seqs/sum(observed_final_seqs))
#
#log_rf ~ Uniform(0, 12)
#p_initial ~ Dirichlet
#rf = 2**log_rf
#
#observed_initial_pfus ~ Multinomial(size=sum(observed_initial_pfus), prob=p_initial)
#p_final = rf*p_initial
#observed_final_pfus ~ Multinomial(size=sum(observed_final_pfus), prob=p_final)
#
#this does not seem completely faithful to the way the simulation is done
#above how would you do it?
data = list("p0"=observed_initial_pfus, "p1"=observed_final_pfus)
set.seed(1)
nseqs = 500000
nstrains = 140
npfus = 10000
#experiment:
# npfus distributed amoung nstrains viruses (input), grown by a factor of rf (final)
# proportions of viruses in input and final are determined via sequencing
# total number of PFUs in final sample is determined via taqman ct
# initial number of PFUs is assumed to be 10000
# task: find rf
#generating simulated data which holds the place of the unobserved "real" data
initial_proportions = rlnorm(n=nstrains, meanlog=log(1/nstrains), sdlog=0.7)
initial_proportions = initial_proportions/sum(initial_proportions)
rfs = 2**(runif(nstrains,0,11))
initial_pfus = rmultinom(n=1, size=npfus, prob=initial_proportions)
final_pfus = initial_pfus * rfs
initial_pfu_props = initial_pfus/sum(initial_pfus)
final_pfu_props = final_pfus/sum(final_pfus)
#observed data
observed_initial_seqs = rmultinom(n=1, size=nseqs, prob=initial_pfu_props)
observed_final_seqs = rmultinom(n=1, size=nseqs, prob=final_pfu_props)
observed_initial_total_pfus = 10000 #they dont measure this but tell me that they fix it to
#10000 so for now I assume this is fixed
observed_final_total_pfus = as.integer(sum(final_pfus)*(2**rnorm(1, 0, sd=0.6))) #normally this is measured via
#taqman ct but it amounts to
#sth similiar to this
#how I do it:
#from observed_final_seqs and observed_initial_seqs compute proportions
#multiply the first by observed_final_total_pfus, the former bu observed_initial_total_pfus
#so
observed_initial_pfus = as.integer(observed_initial_total_pfus * (observed_initial_seqs/sum(observed_initial_seqs)))
observed_final_pfus = observed_final_total_pfus * (observed_final_seqs/sum(observed_final_seqs))
#
#priors:
#p1 ~ Dirichlet
#p2 ~ Dirichlet
#
#observed_initial_pfus ~ Multinomial(size=observed_initial_total_pfus, p=p1)
#observed_final_pfus ~ Multinomial(size=observed_final_total_pfus, p=p2)
#
#then sample from the posterior
#Multinomial(size=observed_final_total_pfus, p=p2)/Multinomial(size=observed_initial_total_pfus, p=p1)
#which gives me rf
data = list("p0"=observed_initial_pfus, "p1"=observed_final_pfus)
source("~/Dropbox/data_analysis/MODELING/rf_fitting/rf_sam.R")
source("~/Dropbox/data_analysis/MODELING/rf_fitting/rf_sam.R")
source("~/Dropbox/data_analysis/MODELING/rf_fitting/rf_sam.R")
source("~/Dropbox/data_analysis/MODELING/rf_fitting/rf_sam.R")
source("~/Dropbox/data_analysis/MODELING/rf_fitting/rf_sam.R")
source("~/Dropbox/data_analysis/MODELING/rf_fitting/rf_sam.R")
source("~/Dropbox/data_analysis/MODELING/rf_fitting/rf_sam.R")
source("~/Dropbox/data_analysis/MODELING/rf_fitting/rf_sam.R")
source("~/Dropbox/data_analysis/MODELING/rf_fitting/rf_sam.R")
source("~/Dropbox/data_analysis/MODELING/rf_fitting/rf_sam.R")
source("~/Dropbox/data_analysis/MODELING/rf_fitting/rf_sam.R")
source("~/Dropbox/data_analysis/MODELING/rf_fitting/rf_sam.R")
library("racmacs")
library("Racmacs")
library("Racmacs")
library("Racmacs")
path = "/home/avicenna/Dropbox/databases/acorg_database/h3n2/maps/h3map2004.ace"
map = read.acmap(path)
view(map)
library("Racmacs")
bootstrapBlobs()
?bootstrapBlobs()
conf.level=0.68
type(conf.level)
class(conf.level)
# Setup workspace
rm(list = ls())
library(Racmacs)
set.seed(Sys.time())
bootstrap_repeats = 2000
optimizations_per_repeat = 300
gs = 0.1
conf = 0.68
smoothing = 8
methods = list("resample","noisy")
map_dir = '/home/avicenna/Dropbox/data_analysis/H5/adinda/data'
wd = '/home/avicenna/Dropbox/data_analysis/H5/adinda/bootstrap_merged/'
#
for (map_name in list( 'h3map2004_3D')){
map = read.acmap(paste0(file.path(map_dir, map_name),'.ace'))
for (method in methods){
path1 = file.path(wd,'bootstrapped_maps/',map_name)
path2 = file.path(wd,'blobs/',map_name)
bootstrap_path = paste0(path1,'_',method,'.ace')
blobs_path = paste0(path2,'_',method,'.ace')
blobs_html_path = paste0(path2,'_',method,'.html')
map_with_bootstrap_data = bootstrapMap(
map,
method=method,
bootstrap_repeats = bootstrap_repeats,
bootstrap_ags = TRUE,
bootstrap_sr = TRUE,
reoptimize = TRUE,
optimizations_per_repeat = optimizations_per_repeat,
ag_noise_sd = 0.7,
titer_noise_sd = 0.7,
options = list()
)
save.acmap(map_with_bootstrap_data, bootstrap_path)
}
}
# Setup workspace
rm(list = ls())
library(Racmacs)
set.seed(Sys.time())
bootstrap_repeats = 2000
optimizations_per_repeat = 300
gs = 0.1
conf = 0.68
smoothing = 8
methods = list("noisy")
map_dir = '/home/avicenna/Dropbox/data_analysis/H5/adinda/data'
wd = '/home/avicenna/Dropbox/data_analysis/H5/adinda/bootstrap_merged/'
#
for (map_name in list( 'h3map2004_3D')){
map = read.acmap(paste0(file.path(map_dir, map_name),'.ace'))
for (method in methods){
path1 = file.path(wd,'bootstrapped_maps/',map_name)
path2 = file.path(wd,'blobs/',map_name)
bootstrap_path = paste0(path1,'_',method,'.ace')
blobs_path = paste0(path2,'_',method,'.ace')
blobs_html_path = paste0(path2,'_',method,'.html')
map_with_bootstrap_data = bootstrapMap(
map,
method=method,
bootstrap_repeats = bootstrap_repeats,
bootstrap_ags = TRUE,
bootstrap_sr = TRUE,
reoptimize = TRUE,
optimizations_per_repeat = optimizations_per_repeat,
ag_noise_sd = 0.7,
titer_noise_sd = 0.7,
options = list()
)
save.acmap(map_with_bootstrap_data, bootstrap_path)
}
}
library(Racmacs)
?optimizeMap
?bootstrapMap
?view
?view.acmap
>RacViewer.options()
?RacViewer.options()
?RacViewer.options()
library(Racmacs)
optimizeMap()
?optimizeMap()
?RacOptimizer.options()
? pr.view
?view()
racmacs::view
Racmacs::view
?Racmacs::view
?RacViewer.options
?bootstrapMap
library(devtools)
install_github("shwilks/Racmacs")
library("Racmacs")
library("r3js")
library(Racmacs)
?mergeMaps
path = "/home/avicenna/Downloads/march2023-gisaid-download-main/results/sequences.RDS"
data = readRDS(path)
data[[1]]
data[[2]]
data[[3]]
type(data)
class(data)
data[0,0]
data[[0,0]]
data[[1,1]]
data[[1,:]]
data[[1,]]
data[1,]
data[1,6]
data[1,7]
data[1,10]
data[1,8]
data[1,13]
data[1,15]
data[1,15]
data[1,20]
data[1,21]
data[1,22]
data[1,23]
path = "/home/avicenna/Downloads/march2023-gisaid-download-main/results/sequences.RDS"
data = readRDS(path)
write.csv(data, "sequences.csv")
class(data)
write.csv(data$rfm, "sequences.csv")
data = as.tibble(data)
library(tibble)
data = as.tibble(data)
data = as_tibble(data)
write.csv(data$rfm, "sequences.csv")
write.csv(data, "sequences.csv")
write.csv(data, "sequences.csv", row.names=FALSE)
data <- apply(data, 2, as.character)
write.csv(data, "sequences.csv", row.names=FALSE)
load_path = "/home/avicenna/Downloads/march2023-gisaid-download-main/results/sequences.RDS"
save_path = "/home/avicenna/Dropbox/local_packages/InfluenzaTime/data/sequences.csv"
data = readRDS(load_path)
data <- apply(data, 2, as.character)
write.csv(data, save_path, row.names=FALSE)
data[1,]
data[1,1]
data[1:5,1]
data[1,1:5]
load_path = "/home/avicenna/Downloads/march2023-gisaid-download-main/results/sequences.RDS"
save_path = "/home/avicenna/Dropbox/local_packages/InfluenzaTime/data/sequences.csv"
data = readRDS(load_path)
data <- apply(data, 2, as.character)
write.csv(data, save_path, row.names=FALSE)
.libPaths()
library(Racmacs)
view(map)
library(Racmacs)
path = "/home/avicenna/Dropbox/data_analysis/COVID/WHO/lab_sera/data/adjusted_merge_subset_coloured.ace"
map = read.acmap(path)
view(map)
library(Racmacs)
path = "/home/avicenna/Dropbox/data_analysis/COVID/WHO/lab_sera/data/adjusted_merge_subset_coloured.ace"
map = read.acmap(path)
view(map)
library(webshot2)
?webshot
Sys.sleep(1)
install.packages("Racmacs")
install_github("acorg/racmacs")
library(devtools)
install.packages(devtools)
install.packages("devtools")
library(devtools)
install_github("acorg/racmacs")
install_github("acorg/ablandscapes")
library(Racmacs)
library(ablandscapes)
?lndscp3d_surface
?lndscp3d_surface
install.packages("Racmacs")
setwd("~/Dropbox/data_analysis/H5/adinda/titer_corrections/H5-antigenic-evolution/bootstrap_analysis")
setwd("~/Dropbox/data_analysis/H5/adinda/titer_corrections/H5-antigenic-evolution/bootstrap_analysis")
# Setup workspace
rm(list = ls())
library(Racmacs)
set.seed(Sys.time())
bootstrap_repeats = 1000
optimizations_per_repeat = 150
gs = 0.1
conf = 0.68
smoothing = 8
method = "bayesian"
map_path = "./input/H5_merge_n3_march_2025.ace"
save_path = "./outputs/bootstrapped_map_bayesian.ace"
map = read.acmap(map_path)
# Setup workspace
rm(list = ls())
library(Racmacs)
set.seed(Sys.time())
bootstrap_repeats = 1000
optimizations_per_repeat = 150
gs = 0.1
conf = 0.68
smoothing = 8
method = "bayesian"
map_path = "./inputs/H5_merge_n3_march_2025.ace"
save_path = "./outputs/bootstrapped_map_bayesian.ace"
map = read.acmap(map_path)
map_with_bootstrap_data = bootstrapMap(
map,
method=method,
bootstrap_repeats = bootstrap_repeats,
bootstrap_ags = TRUE,
bootstrap_sr = TRUE,
reoptimize = TRUE,
optimizations_per_repeat = optimizations_per_repeat,
ag_noise_sd = 0.7,
titer_noise_sd = 0.7,
options = list()
)
save.acmap(map_with_bootstrap_data, save_path)
