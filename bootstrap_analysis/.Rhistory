#sth similiar to this
#how I do it:
#from observed_final_seqs and observed_initial_seqs compute proportions
#multiply the first by observed_final_total_pfus, the former bu observed_initial_total_pfus
#so
observed_initial_pfus = as.integer(observed_initial_total_pfus * observed_initial_seqs/sum(observed_initial_seqs))
observed_final_pfus = as.integer(observed_final_total_pfus * observed_final_seqs/sum(observed_final_seqs))
#
#rf ~ some prior
#p_initial ~ some prior
#
#observed_initial_pfus ~ Multinomial(size=sum(observed_initial_pfus), prob=p_initial)
#p_final = rf*p_initial
#observed_final_pfus ~ Multinomial(size=sum(observed_final_pfus), prob=p_final)
#
#this does not seem completely faithful to the way the simulation is done
#above how would you do it?
data = list("p0"=observed_initial_pfus, "p1"=observed_final_pfus)
View(data)
observed_final_total_pfus * observed_final_seqs/sum(observed_final_seqs)
rfs
set.seed(1)
nseqs = 500000
nstrains = 140
npfus = 10000
#experiment:
# npfus distributed amoung nstrains viruses (input), grown by a factor of rf (final)
# proportions of viruses in input and final are determined via sequencing
# total number of PFUs in final sample is determined via taqman ct
# initial number of PFUs is assumed to be 10000
# task: find rf
#generating simulated data which holds the place of the unobserved "real" data
simulated_input_proportions = runif(nstrains)
simulated_input_proportions = simulated_input_proportions/sum(simulated_input_proportions)
simulated_rfs = 2**(runif(nstrains)*12)
simulated_initial_pfus = rmultinom(n=1, size=npfus, prob=simulated_input_proportions)
simulated_final_pfus = simulated_initial_pfus * simulated_rfs
simulated_initial_pfu_props = simulated_initial_pfus/sum(simulated_initial_pfus)
simulated_final_pfu_props = simulated_final_pfus/sum(simulated_final_pfus)
#observed data
observed_initial_seqs = rmultinom(n=1, size=nseqs, prob=simulated_initial_pfu_props)
observed_final_seqs = rmultinom(n=1, size=nseqs, prob=simulated_final_pfu_props)
observed_initial_total_pfus = 10000 #they dont measure this but tell me that they fix it to
#10000 so for now I assume this is fixed
observed_final_total_pfus = as.integer(sum(simulated_final_pfus)*(2**rnorm(1, 0, sd=0.6))) #normally this is measured via
#taqman ct but it amounts to
#sth similiar to this
#how I do it:
#from observed_final_seqs and observed_initial_seqs compute proportions
#multiply the first by observed_final_total_pfus, the former bu observed_initial_total_pfus
#so
observed_initial_pfus = as.integer(observed_initial_total_pfus * (observed_initial_seqs/sum(observed_initial_seqs)))
observed_final_pfus = observed_final_total_pfus * (observed_final_seqs/sum(observed_final_seqs))
#
#rf ~ some prior
#p_initial ~ some prior
#
#observed_initial_pfus ~ Multinomial(size=sum(observed_initial_pfus), prob=p_initial)
#p_final = rf*p_initial
#observed_final_pfus ~ Multinomial(size=sum(observed_final_pfus), prob=p_final)
#
#this does not seem completely faithful to the way the simulation is done
#above how would you do it?
data = list("p0"=observed_initial_pfus, "p1"=observed_final_pfus)
View(data)
set.seed(1)
nseqs = 500000
nstrains = 140
npfus = 10000
#experiment:
# npfus distributed amoung nstrains viruses (input), grown by a factor of rf (final)
# proportions of viruses in input and final are determined via sequencing
# total number of PFUs in final sample is determined via taqman ct
# initial number of PFUs is assumed to be 10000
# task: find rf
#generating simulated data which holds the place of the unobserved "real" data
initial_proportions = runif(nstrains)
initial_proportions = initial_proportions/sum(initial_proportions)
rfs = 2**(runif(nstrains)*12)
initial_pfus = rmultinom(n=1, size=npfus, prob=initial_proportions)
final_pfus = initial_pfus * rfs
initial_pfu_props = initial_pfus/sum(initial_pfus)
final_pfu_props = final_pfus/sum(final_pfus)
#observed data
observed_initial_seqs = rmultinom(n=1, size=nseqs, prob=initial_pfu_props)
observed_final_seqs = rmultinom(n=1, size=nseqs, prob=final_pfu_props)
observed_initial_total_pfus = 10000 #they dont measure this but tell me that they fix it to
#10000 so for now I assume this is fixed
observed_final_total_pfus = as.integer(sum(final_pfus)*(2**rnorm(1, 0, sd=0.6))) #normally this is measured via
#taqman ct but it amounts to
#sth similiar to this
#how I do it:
#from observed_final_seqs and observed_initial_seqs compute proportions
#multiply the first by observed_final_total_pfus, the former bu observed_initial_total_pfus
#so
observed_initial_pfus = as.integer(observed_initial_total_pfus * (observed_initial_seqs/sum(observed_initial_seqs)))
observed_final_pfus = observed_final_total_pfus * (observed_final_seqs/sum(observed_final_seqs))
#
#log_rf ~ Uniform(0, 12)
#p_initial ~ Dirichlet
#rf = 2**log_rf
#
#observed_initial_pfus ~ Multinomial(size=sum(observed_initial_pfus), prob=p_initial)
#p_final = rf*p_initial
#observed_final_pfus ~ Multinomial(size=sum(observed_final_pfus), prob=p_final)
#
#this does not seem completely faithful to the way the simulation is done
#above how would you do it?
data = list("p0"=observed_initial_pfus, "p1"=observed_final_pfus)
set.seed(1)
nseqs = 500000
nstrains = 140
npfus = 10000
#experiment:
# npfus distributed amoung nstrains viruses (input), grown by a factor of rf (final)
# proportions of viruses in input and final are determined via sequencing
# total number of PFUs in final sample is determined via taqman ct
# initial number of PFUs is assumed to be 10000
# task: find rf
#generating simulated data which holds the place of the unobserved "real" data
initial_proportions = runif(nstrains)
initial_proportions = initial_proportions/sum(initial_proportions)
rfs = 2**(runif(nstrains)*12)
initial_pfus = rmultinom(n=1, size=npfus, prob=initial_proportions)
final_pfus = initial_pfus * rfs
initial_pfu_props = initial_pfus/sum(initial_pfus)
final_pfu_props = final_pfus/sum(final_pfus)
#observed data
observed_initial_seqs = rmultinom(n=1, size=nseqs, prob=initial_pfu_props)
observed_final_seqs = rmultinom(n=1, size=nseqs, prob=final_pfu_props)
observed_initial_total_pfus = 10000 #they dont measure this but tell me that they fix it to
#10000 so for now I assume this is fixed
observed_final_total_pfus = as.integer(sum(final_pfus)*(2**rnorm(1, 0, sd=0.6))) #normally this is measured via
#taqman ct but it amounts to
#sth similiar to this
#how I do it:
#from observed_final_seqs and observed_initial_seqs compute proportions
#multiply the first by observed_final_total_pfus, the former bu observed_initial_total_pfus
#so
observed_initial_pfus = as.integer(observed_initial_total_pfus * (observed_initial_seqs/sum(observed_initial_seqs)))
observed_final_pfus = observed_final_total_pfus * (observed_final_seqs/sum(observed_final_seqs))
#
#log_rf ~ Uniform(0, 12)
#p_initial ~ Dirichlet
#rf = 2**log_rf
#
#observed_initial_pfus ~ Multinomial(size=sum(observed_initial_pfus), prob=p_initial)
#p_final = rf*p_initial
#observed_final_pfus ~ Multinomial(size=sum(observed_final_pfus), prob=p_final)
#
#this does not seem completely faithful to the way the simulation is done
#above how would you do it?
data = list("p0"=observed_initial_pfus, "p1"=observed_final_pfus)
set.seed(1)
nseqs = 500000
nstrains = 140
npfus = 10000
#experiment:
# npfus distributed amoung nstrains viruses (input), grown by a factor of rf (final)
# proportions of viruses in input and final are determined via sequencing
# total number of PFUs in final sample is determined via taqman ct
# initial number of PFUs is assumed to be 10000
# task: find rf
#generating simulated data which holds the place of the unobserved "real" data
initial_proportions = rlnorm(n=nstrains, meanlog=log(1/nstrains), sdlog=0.7)
initial_proportions = initial_proportions/sum(initial_proportions)
rfs = 2**(runif(nstrains,0,11))
initial_pfus = rmultinom(n=1, size=npfus, prob=initial_proportions)
final_pfus = initial_pfus * rfs
initial_pfu_props = initial_pfus/sum(initial_pfus)
final_pfu_props = final_pfus/sum(final_pfus)
#observed data
observed_initial_seqs = rmultinom(n=1, size=nseqs, prob=initial_pfu_props)
observed_final_seqs = rmultinom(n=1, size=nseqs, prob=final_pfu_props)
observed_initial_total_pfus = 10000 #they dont measure this but tell me that they fix it to
#10000 so for now I assume this is fixed
observed_final_total_pfus = as.integer(sum(final_pfus)*(2**rnorm(1, 0, sd=0.6))) #normally this is measured via
#taqman ct but it amounts to
#sth similiar to this
#how I do it:
#from observed_final_seqs and observed_initial_seqs compute proportions
#multiply the first by observed_final_total_pfus, the former bu observed_initial_total_pfus
#so
observed_initial_pfus = as.integer(observed_initial_total_pfus * (observed_initial_seqs/sum(observed_initial_seqs)))
observed_final_pfus = observed_final_total_pfus * (observed_final_seqs/sum(observed_final_seqs))
#
#priors:
#p1 ~ Dirichlet
#p2 ~ Dirichlet
#
#observed_initial_pfus ~ Multinomial(size=observed_initial_total_pfus, p=p1)
#observed_final_pfus ~ Multinomial(size=observed_final_total_pfus, p=p2)
#
#then sample from the posterior
#Multinomial(size=observed_final_total_pfus, p=p2)/Multinomial(size=observed_initial_total_pfus, p=p1)
#which gives me rf
data = list("p0"=observed_initial_pfus, "p1"=observed_final_pfus)
source("~/Dropbox/data_analysis/MODELING/rf_fitting/rf_sam.R")
source("~/Dropbox/data_analysis/MODELING/rf_fitting/rf_sam.R")
source("~/Dropbox/data_analysis/MODELING/rf_fitting/rf_sam.R")
source("~/Dropbox/data_analysis/MODELING/rf_fitting/rf_sam.R")
source("~/Dropbox/data_analysis/MODELING/rf_fitting/rf_sam.R")
source("~/Dropbox/data_analysis/MODELING/rf_fitting/rf_sam.R")
source("~/Dropbox/data_analysis/MODELING/rf_fitting/rf_sam.R")
source("~/Dropbox/data_analysis/MODELING/rf_fitting/rf_sam.R")
source("~/Dropbox/data_analysis/MODELING/rf_fitting/rf_sam.R")
source("~/Dropbox/data_analysis/MODELING/rf_fitting/rf_sam.R")
source("~/Dropbox/data_analysis/MODELING/rf_fitting/rf_sam.R")
source("~/Dropbox/data_analysis/MODELING/rf_fitting/rf_sam.R")
library("racmacs")
library("Racmacs")
library("Racmacs")
library("Racmacs")
path = "/home/avicenna/Dropbox/databases/acorg_database/h3n2/maps/h3map2004.ace"
map = read.acmap(path)
view(map)
library("Racmacs")
bootstrapBlobs()
?bootstrapBlobs()
conf.level=0.68
type(conf.level)
class(conf.level)
# Setup workspace
rm(list = ls())
library(Racmacs)
set.seed(Sys.time())
bootstrap_repeats = 2000
optimizations_per_repeat = 300
gs = 0.1
conf = 0.68
smoothing = 8
methods = list("resample","noisy")
map_dir = '/home/avicenna/Dropbox/data_analysis/H5/adinda/data'
wd = '/home/avicenna/Dropbox/data_analysis/H5/adinda/bootstrap_merged/'
#
for (map_name in list( 'h3map2004_3D')){
map = read.acmap(paste0(file.path(map_dir, map_name),'.ace'))
for (method in methods){
path1 = file.path(wd,'bootstrapped_maps/',map_name)
path2 = file.path(wd,'blobs/',map_name)
bootstrap_path = paste0(path1,'_',method,'.ace')
blobs_path = paste0(path2,'_',method,'.ace')
blobs_html_path = paste0(path2,'_',method,'.html')
map_with_bootstrap_data = bootstrapMap(
map,
method=method,
bootstrap_repeats = bootstrap_repeats,
bootstrap_ags = TRUE,
bootstrap_sr = TRUE,
reoptimize = TRUE,
optimizations_per_repeat = optimizations_per_repeat,
ag_noise_sd = 0.7,
titer_noise_sd = 0.7,
options = list()
)
save.acmap(map_with_bootstrap_data, bootstrap_path)
}
}
# Setup workspace
rm(list = ls())
library(Racmacs)
set.seed(Sys.time())
bootstrap_repeats = 2000
optimizations_per_repeat = 300
gs = 0.1
conf = 0.68
smoothing = 8
methods = list("noisy")
map_dir = '/home/avicenna/Dropbox/data_analysis/H5/adinda/data'
wd = '/home/avicenna/Dropbox/data_analysis/H5/adinda/bootstrap_merged/'
#
for (map_name in list( 'h3map2004_3D')){
map = read.acmap(paste0(file.path(map_dir, map_name),'.ace'))
for (method in methods){
path1 = file.path(wd,'bootstrapped_maps/',map_name)
path2 = file.path(wd,'blobs/',map_name)
bootstrap_path = paste0(path1,'_',method,'.ace')
blobs_path = paste0(path2,'_',method,'.ace')
blobs_html_path = paste0(path2,'_',method,'.html')
map_with_bootstrap_data = bootstrapMap(
map,
method=method,
bootstrap_repeats = bootstrap_repeats,
bootstrap_ags = TRUE,
bootstrap_sr = TRUE,
reoptimize = TRUE,
optimizations_per_repeat = optimizations_per_repeat,
ag_noise_sd = 0.7,
titer_noise_sd = 0.7,
options = list()
)
save.acmap(map_with_bootstrap_data, bootstrap_path)
}
}
library(Racmacs)
?optimizeMap
?bootstrapMap
?view
?view.acmap
>RacViewer.options()
?RacViewer.options()
?RacViewer.options()
library(Racmacs)
optimizeMap()
?optimizeMap()
?RacOptimizer.options()
? pr.view
?view()
racmacs::view
Racmacs::view
?Racmacs::view
?RacViewer.options
?bootstrapMap
library(devtools)
install_github("shwilks/Racmacs")
library("Racmacs")
library("r3js")
library(Racmacs)
?mergeMaps
path = "/home/avicenna/Downloads/march2023-gisaid-download-main/results/sequences.RDS"
data = readRDS(path)
data[[1]]
data[[2]]
data[[3]]
type(data)
class(data)
data[0,0]
data[[0,0]]
data[[1,1]]
data[[1,:]]
data[[1,]]
data[1,]
data[1,6]
data[1,7]
data[1,10]
data[1,8]
data[1,13]
data[1,15]
data[1,15]
data[1,20]
data[1,21]
data[1,22]
data[1,23]
path = "/home/avicenna/Downloads/march2023-gisaid-download-main/results/sequences.RDS"
data = readRDS(path)
write.csv(data, "sequences.csv")
class(data)
write.csv(data$rfm, "sequences.csv")
data = as.tibble(data)
library(tibble)
data = as.tibble(data)
data = as_tibble(data)
write.csv(data$rfm, "sequences.csv")
write.csv(data, "sequences.csv")
write.csv(data, "sequences.csv", row.names=FALSE)
data <- apply(data, 2, as.character)
write.csv(data, "sequences.csv", row.names=FALSE)
load_path = "/home/avicenna/Downloads/march2023-gisaid-download-main/results/sequences.RDS"
save_path = "/home/avicenna/Dropbox/local_packages/InfluenzaTime/data/sequences.csv"
data = readRDS(load_path)
data <- apply(data, 2, as.character)
write.csv(data, save_path, row.names=FALSE)
data[1,]
data[1,1]
data[1:5,1]
data[1,1:5]
load_path = "/home/avicenna/Downloads/march2023-gisaid-download-main/results/sequences.RDS"
save_path = "/home/avicenna/Dropbox/local_packages/InfluenzaTime/data/sequences.csv"
data = readRDS(load_path)
data <- apply(data, 2, as.character)
write.csv(data, save_path, row.names=FALSE)
.libPaths()
library(Racmacs)
view(map)
library(Racmacs)
path = "/home/avicenna/Dropbox/data_analysis/COVID/WHO/lab_sera/data/adjusted_merge_subset_coloured.ace"
map = read.acmap(path)
view(map)
library(Racmacs)
path = "/home/avicenna/Dropbox/data_analysis/COVID/WHO/lab_sera/data/adjusted_merge_subset_coloured.ace"
map = read.acmap(path)
view(map)
library(webshot2)
?webshot
Sys.sleep(1)
install.packages("Racmacs")
install_github("acorg/racmacs")
library(devtools)
install.packages(devtools)
install.packages("devtools")
library(devtools)
install_github("acorg/racmacs")
install_github("acorg/ablandscapes")
library(Racmacs)
library(ablandscapes)
?lndscp3d_surface
?lndscp3d_surface
setwd("~/Dropbox/data_analysis/H5/adinda/titer_corrections/H5-antigenic-evolution/bootstrap_analysis")
# Setup workspace
rm(list = ls())
library(Racmacs)
set.seed(Sys.time())
bootstrap_repeats = 1000
optimizations_per_repeat = 150
gs = 0.1
conf = 0.68
smoothing = 6
method = "bayesian"
input_path = "./outputs/bootstrapped_map_bayesian.ace"
blobs = bootstrapBlobs(read.acmap(input_path), conf.level = 0.6, gridspacing = 1,
smoothing=smoothing)
sr_blobs = srBootstrapBlobs(blobs)
#17, 21, 29
View(sr_blobs)
srNames(blobs[[21]])
srNames(blobs)[[21]]
srNames(blobs)
srNames(blobs)[[17]]
srNames(blobs)[[21]]
srNames(blobs)[[29]]
View(sr_blobs)
sr_blobs[[21]][[2]][["vertices"]]
sr_blobs[[21]][[2]][["vertices"]]
sr_blobs[[21]][[1]][["vertices"]]
sr_blobs[[17]][[1]][["vertices"]]
sr_blobs[[17]][[2]][["faces"]]
sr_blobs[[29]][[1]][["faces"]]
sr_blobs[[29]][[1]][["faces"]]
sr_blobs[[29]][[2]][["faces"]]
View(sr_blobs)
ag_blobs = agBootstrapBlobs(blobs)
View(ag_blobs)
srNames(ag_blobs)[[17]]
srNames(blobs)[[17]]
srNames(blobs)[[21]]
pr.view(blobs)
view(blobs)
sr_blobs[[29]][[1]][["faces"]]
sr_blobs[[29]][[2]][["faces"]]
srNames(blobs)[[21]]
sr_blobs[[29]][[1]][["vertices"]][[30]]
sr_blobs[[29]][[1]][["vertices"]][[30,]]
sr_blobs[[29]][[1]][["vertices"]]
srNames(blobs)[[17]]
srNames(blobs)[[19]]
srNames(blobs)[[21]]
sr_blobs[[21]][[2]][["faces"]]
sr_blobs[[21]][[1]][["faces"]]
ag_blobs[[22]][[1]][["faces"]]
agNames(blobs)[[22]]
# Setup workspace
rm(list = ls())
library(Racmacs)
set.seed(Sys.time())
bootstrap_repeats = 1000
optimizations_per_repeat = 150
gs = 0.1
conf = 0.68
smoothing = 8
method = "bayesian"
input_path = "./outputs/bootstrapped_map_bayesian.ace"
blobs = bootstrapBlobs(read.acmap(input_path), conf.level = 0.68,
gridspacing = 0.25, smoothing=smoothing)
sr_blobs = srBootstrapBlobs(blobs)
ag_blobs = agBootstrapBlobs(blobs)
#17, 21, 29
View(sr_blobs)
sr_names(blobs)[[29]]
srNames(blobs)[[29]]
View(ag_blobs)
agNames(blobs)[[16]]
agNames(blobs)[[18]]
agNames(blobs)[[20]]
agNames(blobs)[[21]]
agNames(blobs)[[22]]
agNames(blobs)[[82]]
agNames(blobs)[[83]]
### Code to generate antigenic map visualization with antigens colored based on bootstrap blob size, as in Data S3F.
### Analysis described in supplementary text S3
rm(list = ls())
library(Racmacs)
library(dplyr)
#files
ag_boot_vol <- read.csv("./tables/vol_ag.csv")
map <- read.acmap("./inputs/H5_merge_n3_march_2025.ace")
#convert NA to 0
ag_boot_vol[is.na(ag_boot_vol)] <- 0
#convert volumes to radii
ag_boot_radius <- (ag_boot_vol[,c(2,3)]/(4/3*pi))^(1/3)
rownames(ag_boot_radius) <- ag_boot_vol[,1]
#make column of total radius (since some ag have 2 blobs)
ag_boot_radius <- ag_boot_radius %>% mutate(total = X0+X1)
#color pallete (generated using viridis::viridis(n=100, option = "rocket", direction = -1))
rocket_pal <- c("#FAEBDDFF", "#FAE7D7FF", "#F9E3D2FF", "#F9DFCBFF", "#F8DBC6FF", "#F8D7C0FF", "#F8D4BBFF", "#F7D0B5FF", "#F7CCB0FF", "#F7C9AAFF", "#F7C5A4FF",
"#F6C09EFF", "#F6BC99FF", "#F6B894FF", "#F6B48FFF", "#F6B08AFF", "#F6AD85FF", "#F6A880FF", "#F6A47BFF", "#F6A077FF", "#F69B72FF", "#F5976EFF",
"#F5936AFF", "#F58F66FF", "#F58A61FF", "#F4855EFF", "#F4815AFF", "#F47C56FF", "#F37852FF", "#F3734FFF", "#F26E4CFF", "#F26948FF", "#F16546FF",
"#F06043FF", "#EF5B42FF", "#EF5640FF", "#ED513EFF", "#EC4B3EFF", "#EB463EFF", "#E8413EFF", "#E73D3FFF", "#E43841FF", "#E23442FF", "#DF2F44FF",
"#DD2C45FF", "#D92847FF", "#D62549FF", "#D3214BFF", "#D01E4DFF", "#CD1C4EFF", "#C81951FF", "#C51852FF", "#C11754FF", "#BD1656FF", "#B91657FF",
"#B41658FF", "#B01759FF", "#AB185AFF", "#A7185AFF", "#A3195BFF", "#9E1A5BFF", "#9A1B5BFF", "#961C5BFF", "#921C5BFF", "#8C1D5BFF", "#881E5BFF",
"#841E5AFF", "#801E5AFF", "#7B1F59FF", "#761F58FF", "#721F58FF", "#6E1F57FF", "#6A1F56FF", "#661F54FF", "#621F53FF", "#5E1F52FF", "#591E50FF",
"#551E4FFF", "#511E4DFF", "#4D1D4BFF", "#491D49FF", "#451C47FF", "#421B45FF", "#3D1A42FF", "#391A41FF", "#35193EFF", "#32183BFF", "#2E1739FF",
"#2A1636FF", "#271534FF", "#221331FF", "#1F122DFF", "#1B112BFF", "#170F28FF", "#140E26FF", "#100B23FF", "#0D0A21FF", "#08081EFF", "#06071CFF",
"#03051AFF")
ag_boot_radius$col <- rocket_pal[as.numeric(cut(ag_boot_radius$total, breaks = 100))]
map_bootstrap_cols <- map
srOutline(map_bootstrap_cols) <- "black"
agSize(map_bootstrap_cols) <- 3
agFill(map_bootstrap_cols) <- ag_boot_radius$col[match(agNames(map), rownames(ag_boot_radius))]
map_bootstrap_cols <- setLegend(map_bootstrap_cols,
legend = rev(round(seq(min(ag_boot_radius$total), max(ag_boot_radius$total), length.out = 7), digits = 1)),
fill   = rev(c("#FAEBDDFF", "#F6AA82FF", "#F06043FF", "#CB1B4FFF", "#841E5AFF", "#3F1B44FF", "#03051AFF"))) #using viridis::viridis(n=7, option = "rocket", direction = -1)
Racmacs::view(map_bootstrap_cols, options = RacViewer.options(point.opacity = 0.8))
